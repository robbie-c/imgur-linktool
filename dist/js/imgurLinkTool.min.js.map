{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/querystringify/index.js","imgurLinkTool.min.js","node_modules/requires-port/index.js","node_modules/url-parse/index.js","node_modules/url-parse/lolcation.js","src/imgurLinkTool.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","ImgurLinkTool","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"querystring","query","part","parser","result","exec","decodeURIComponent","querystringify","obj","prefix","pairs","key","has","push","encodeURIComponent","join","Object","prototype","hasOwnProperty","stringify","parse",2,"port","protocol","split",3,"URL","address","location","instruction","index","relative","relativere","test","type","url","qs","lolcation","instructions","indexOf","slice","toLowerCase","required","host","hostname","username","password","auth","href","toString","NaN","undefined","set","value","fn","pathname","charAt","hash","./lolcation","requires-port",4,"ignore","loc","finaldestination","unescape","./",5,"urlString","urlParseResult","urlParse","validHostNames","pathComponents","id","subreddit","pages","nameComponents","fileType","parsedToImageId","parsedUrl","imageIdFromUrl","_validHostNames","_pages","url-parse"],"mappings":"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","file":"imgurLinkTool.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.ImgurLinkTool = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , relativere = /^\\/(?!\\/)/;\n\n/**\n * These are the parse instructions for the URL parsers, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar instructions = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['//', 'protocol', 2, 1, 1],          // Extract from the front.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/\\:(\\d+)$/, 'port'],                 // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my CDO.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Boolean|function} parser Parser for the query string.\n * @param {Object} location Location defaults for relative paths.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative = relativere.test(address)\n    , parse, instruction, index, key\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) {\n    parser = qs.parse;\n  }\n\n  location = lolcation(location);\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, address.length - index[0].length);\n    }\n\n    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) {\n      url[key] = url[key].toLowerCase();\n    }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} prop Property we need to adjust.\n * @param {Mixed} value The newly assigned value.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  if ('query' === part) {\n    if ('string' === typeof value && value.length) {\n      value = (fn || qs.parse)(value);\n    }\n\n    url[part] = value;\n  } else if ('port' === part) {\n    url[part] = value;\n\n    if (!required(value, url.protocol)) {\n      url.host = url.hostname;\n      url[part] = '';\n    } else if (value) {\n      url.host = url.hostname +':'+ value;\n    }\n  } else if ('hostname' === part) {\n    url[part] = value;\n\n    if (url.port) value += ':'+ url.port;\n    url.host = value;\n  } else if ('host' === part) {\n    url[part] = value;\n\n    if (/\\:\\d+/.test(value)) {\n      value = value.split(':');\n      url.hostname = value[0];\n      url.port = value[1];\n    }\n  } else {\n    url[part] = value;\n  }\n\n  url.href = url.toString();\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , result = url.protocol +'//';\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.hostname;\n  if (url.port) result += ':'+ url.port;\n\n  result += url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others.\n//\nURL.qs = qs;\nURL.location = lolcation;\nmodule.exports = URL;\n\n},{\"./lolcation\":4,\"querystringify\":1,\"requires-port\":2}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as the a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 }\n  , URL;\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nmodule.exports = function lolcation(loc) {\n  loc = loc || global.location || {};\n  URL = URL || require('./');\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) for (key in loc) {\n    if (key in ignore) continue;\n    finaldestination[key] = loc[key];\n  }\n\n  return finaldestination;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./\":3}],5:[function(require,module,exports){\nvar urlParse = require('url-parse');\n\n// these are the host names which an imgur image could exist on\nvar validHostNames = ['imgur.com', 'www.imgur.com', 'i.imgur.com', 'm.imgur.com'];\n\n// these are the pages on imgur.com that are in the id namespace but are not ids\nvar pages = ['about', 'help', 'blog', 'tos', 'privacy', 'apps', 'api', 'advertise', 'privacy', 'removalrequest', 'jobs'];\n\nfunction parse(urlString) {\n  var urlParseResult = urlParse(urlString);\n\n  // make sure that the url we have been given is actually imgur\n  if (validHostNames.indexOf(urlParseResult.hostname) === -1) {\n    return null;\n  }\n\n  var pathComponents = urlParseResult.pathname.split('/'); // the 0th component is always empty\n\n  if (pathComponents.length === 3 && pathComponents[1] === 'gallery') {\n    return {\n      type: 'gallery',\n      id: pathComponents[2]\n    };\n  } else if (pathComponents.length === 4 && pathComponents[1] === 'r') {\n    return {\n      type: 'reddit',\n      subreddit: pathComponents[2],\n      id: pathComponents[3]\n    };\n  } else if (pathComponents.length === 3 && pathComponents[1] === 'a') {\n    return {\n      type: 'album',\n      id: pathComponents[2]\n    };\n  } else if (pathComponents.length === 2 && pages.indexOf(pathComponents[1]) === -1) {\n    var nameComponents = pathComponents[1].split('.');\n    if (nameComponents.length <= 2) {\n      return {\n        type: 'image',\n        id: nameComponents[0],\n        fileType: nameComponents[1]\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction parsedToImageId(parsedUrl) {\n  if (parsedUrl) {\n    if (parsedUrl.type === 'gallery' || parsedUrl.type === 'reddit' || parsedUrl.type === 'image') {\n      return parsedUrl.id;\n    } else if (parsedUrl.type === 'album') {\n      // TODO no idea what to do here\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction imageIdFromUrl(urlString) {\n  return parsedToImageId(parse(urlString));\n}\n\nmodule.exports = {\n  _validHostNames: validHostNames,\n  _pages: pages,\n  parse: parse,\n  parsedToImageId: parsedToImageId,\n  imageIdFromUrl: imageIdFromUrl\n};\n\n},{\"url-parse\":3}]},{},[5])(5)\n});\n\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , relativere = /^\\/(?!\\/)/;\n\n/**\n * These are the parse instructions for the URL parsers, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar instructions = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['//', 'protocol', 2, 1, 1],          // Extract from the front.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/\\:(\\d+)$/, 'port'],                 // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my CDO.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Boolean|function} parser Parser for the query string.\n * @param {Object} location Location defaults for relative paths.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative = relativere.test(address)\n    , parse, instruction, index, key\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) {\n    parser = qs.parse;\n  }\n\n  location = lolcation(location);\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, address.length - index[0].length);\n    }\n\n    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) {\n      url[key] = url[key].toLowerCase();\n    }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} prop Property we need to adjust.\n * @param {Mixed} value The newly assigned value.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  if ('query' === part) {\n    if ('string' === typeof value && value.length) {\n      value = (fn || qs.parse)(value);\n    }\n\n    url[part] = value;\n  } else if ('port' === part) {\n    url[part] = value;\n\n    if (!required(value, url.protocol)) {\n      url.host = url.hostname;\n      url[part] = '';\n    } else if (value) {\n      url.host = url.hostname +':'+ value;\n    }\n  } else if ('hostname' === part) {\n    url[part] = value;\n\n    if (url.port) value += ':'+ url.port;\n    url.host = value;\n  } else if ('host' === part) {\n    url[part] = value;\n\n    if (/\\:\\d+/.test(value)) {\n      value = value.split(':');\n      url.hostname = value[0];\n      url.port = value[1];\n    }\n  } else {\n    url[part] = value;\n  }\n\n  url.href = url.toString();\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , result = url.protocol +'//';\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.hostname;\n  if (url.port) result += ':'+ url.port;\n\n  result += url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others.\n//\nURL.qs = qs;\nURL.location = lolcation;\nmodule.exports = URL;\n","'use strict';\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as the a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 }\n  , URL;\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nmodule.exports = function lolcation(loc) {\n  loc = loc || global.location || {};\n  URL = URL || require('./');\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) for (key in loc) {\n    if (key in ignore) continue;\n    finaldestination[key] = loc[key];\n  }\n\n  return finaldestination;\n};\n","var urlParse = require('url-parse');\n\n// these are the host names which an imgur image could exist on\nvar validHostNames = [\n  'imgur.com',\n  'www.imgur.com',\n  'i.imgur.com',\n  'm.imgur.com'\n];\n\n// these are the pages on imgur.com that are in the id namespace but are not ids\nvar pages = [\n  'about',\n  'help',\n  'blog',\n  'tos',\n  'privacy',\n  'apps',\n  'api',\n  'advertise',\n  'privacy',\n  'removalrequest',\n  'jobs'\n];\n\nfunction parse(urlString) {\n  var urlParseResult = urlParse(urlString);\n\n  // make sure that the url we have been given is actually imgur\n  if (validHostNames.indexOf(urlParseResult.hostname) === -1) {\n    return null;\n  }\n\n  var pathComponents = urlParseResult.pathname.split('/'); // the 0th component is always empty\n\n  if ((pathComponents.length === 3) && (pathComponents[1] === 'gallery')) {\n    return {\n      type: 'gallery',\n      id: pathComponents[2]\n    };\n  } else if ((pathComponents.length === 4) && (pathComponents[1] === 'r')) {\n    return {\n      type: 'reddit',\n      subreddit: pathComponents[2],\n      id: pathComponents[3]\n    }\n  } else if ((pathComponents.length === 3) && (pathComponents[1] === 'a')) {\n    return {\n      type: 'album',\n      id: pathComponents[2]\n    };\n  } else if ((pathComponents.length === 2) && (pages.indexOf(pathComponents[1]) === -1)) {\n    var nameComponents = pathComponents[1].split('.');\n    if (nameComponents.length <= 2) {\n      return {\n        type: 'image',\n        id: nameComponents[0],\n        fileType: nameComponents[1]\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction parsedToImageId(parsedUrl) {\n  if (parsedUrl) {\n    if (parsedUrl.type === 'gallery' || parsedUrl.type === 'reddit' || parsedUrl.type === 'image') {\n      return parsedUrl.id;\n    } else if (parsedUrl.type === 'album') {\n      // TODO no idea what to do here\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction imageIdFromUrl(urlString) {\n  return parsedToImageId(parse(urlString));\n}\n\nmodule.exports = {\n  _validHostNames: validHostNames,\n  _pages: pages,\n  parse: parse,\n  parsedToImageId: parsedToImageId,\n  imageIdFromUrl: imageIdFromUrl\n};\n"],"sourceRoot":"/source/"}