{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/querystringify/index.js","node_modules/requires-port/index.js","node_modules/url-parse/index.js","node_modules/url-parse/lolcation.js","src/imgurLinkTool.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA,IAAI,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC;;;AAAC,AAGpC,IAAI,cAAc,GAAG,CACnB,WAAW,EACX,eAAe,EACf,aAAa,EACb,aAAa,CACd;;;AAAC,AAGF,IAAI,KAAK,GAAG,CACV,OAAO,EACP,MAAM,EACN,MAAM,EACN,KAAK,EACL,SAAS,EACT,MAAM,EACN,KAAK,EACL,WAAW,EACX,SAAS,EACT,gBAAgB,EAChB,MAAM,CACP,CAAC;;AAEF,SAAS,KAAK,CAAC,SAAS,EAAE;AACxB,MAAI,cAAc,GAAG,QAAQ,CAAC,SAAS,CAAC;;;AAAC,AAGzC,MAAI,cAAc,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;AAC1D,WAAO,IAAI,CAAC;GACb;;AAED,MAAI,cAAc,GAAG,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC;;AAAC,AAExD,MAAI,AAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAAM,cAAc,CAAC,CAAC,CAAC,KAAK,SAAS,AAAC,EAAE;AACtE,WAAO;AACL,UAAI,EAAE,SAAS;AACf,QAAE,EAAE,cAAc,CAAC,CAAC,CAAC;KACtB,CAAC;GACH,MAAM,IAAI,AAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAAM,cAAc,CAAC,CAAC,CAAC,KAAK,GAAG,AAAC,EAAE;AACvE,WAAO;AACL,UAAI,EAAE,QAAQ;AACd,eAAS,EAAE,cAAc,CAAC,CAAC,CAAC;AAC5B,QAAE,EAAE,cAAc,CAAC,CAAC,CAAC;KACtB,CAAA;GACF,MAAM,IAAI,AAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAAM,cAAc,CAAC,CAAC,CAAC,KAAK,GAAG,AAAC,EAAE;AACvE,WAAO;AACL,UAAI,EAAE,OAAO;AACb,QAAE,EAAE,cAAc,CAAC,CAAC,CAAC;KACtB,CAAC;GACH,MAAM,IAAI,AAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAAM,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,AAAC,EAAE;AACrF,QAAI,cAAc,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAClD,QAAI,cAAc,CAAC,MAAM,IAAI,CAAC,EAAE;AAC9B,aAAO;AACL,YAAI,EAAE,OAAO;AACb,UAAE,EAAE,cAAc,CAAC,CAAC,CAAC;AACrB,gBAAQ,EAAE,cAAc,CAAC,CAAC,CAAC;OAC5B,CAAC;KACH,MAAM;AACL,aAAO,IAAI,CAAC;KACb;GACF;;AAED,SAAO,IAAI,CAAC;CACb;;AAED,SAAS,eAAe,CAAC,SAAS,EAAE;AAClC,MAAI,SAAS,EAAE;AACb,QAAI,SAAS,CAAC,IAAI,KAAK,SAAS,IAAI,SAAS,CAAC,IAAI,KAAK,QAAQ,IAAI,SAAS,CAAC,IAAI,KAAK,OAAO,EAAE;AAC7F,aAAO,SAAS,CAAC,EAAE,CAAC;KACrB,MAAM,IAAI,SAAS,CAAC,IAAI,KAAK,OAAO,EAAE;;AAErC,aAAO,IAAI,CAAC;KACb;GACF;AACD,SAAO,IAAI,CAAC;CACb;;AAED,SAAS,cAAc,CAAC,SAAS,EAAE;AACjC,SAAO,eAAe,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;CAC1C;;AAED,MAAM,CAAC,OAAO,GAAG;AACf,iBAAe,EAAE,cAAc;AAC/B,QAAM,EAAE,KAAK;AACb,OAAK,EAAE,KAAK;AACZ,iBAAe,EAAE,eAAe;AAChC,gBAAc,EAAE,cAAc;CAC/B,CAAC","file":"imgurLinkTool.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , relativere = /^\\/(?!\\/)/;\n\n/**\n * These are the parse instructions for the URL parsers, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar instructions = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['//', 'protocol', 2, 1, 1],          // Extract from the front.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/\\:(\\d+)$/, 'port'],                 // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my CDO.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Boolean|function} parser Parser for the query string.\n * @param {Object} location Location defaults for relative paths.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative = relativere.test(address)\n    , parse, instruction, index, key\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) {\n    parser = qs.parse;\n  }\n\n  location = lolcation(location);\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, address.length - index[0].length);\n    }\n\n    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) {\n      url[key] = url[key].toLowerCase();\n    }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} prop Property we need to adjust.\n * @param {Mixed} value The newly assigned value.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  if ('query' === part) {\n    if ('string' === typeof value && value.length) {\n      value = (fn || qs.parse)(value);\n    }\n\n    url[part] = value;\n  } else if ('port' === part) {\n    url[part] = value;\n\n    if (!required(value, url.protocol)) {\n      url.host = url.hostname;\n      url[part] = '';\n    } else if (value) {\n      url.host = url.hostname +':'+ value;\n    }\n  } else if ('hostname' === part) {\n    url[part] = value;\n\n    if (url.port) value += ':'+ url.port;\n    url.host = value;\n  } else if ('host' === part) {\n    url[part] = value;\n\n    if (/\\:\\d+/.test(value)) {\n      value = value.split(':');\n      url.hostname = value[0];\n      url.port = value[1];\n    }\n  } else {\n    url[part] = value;\n  }\n\n  url.href = url.toString();\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , result = url.protocol +'//';\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.hostname;\n  if (url.port) result += ':'+ url.port;\n\n  result += url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others.\n//\nURL.qs = qs;\nURL.location = lolcation;\nmodule.exports = URL;\n","'use strict';\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as the a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 }\n  , URL;\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nmodule.exports = function lolcation(loc) {\n  loc = loc || global.location || {};\n  URL = URL || require('./');\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) for (key in loc) {\n    if (key in ignore) continue;\n    finaldestination[key] = loc[key];\n  }\n\n  return finaldestination;\n};\n","var urlParse = require('url-parse');\n\n// these are the host names which an imgur image could exist on\nvar validHostNames = [\n  'imgur.com',\n  'www.imgur.com',\n  'i.imgur.com',\n  'm.imgur.com'\n];\n\n// these are the pages on imgur.com that are in the id namespace but are not ids\nvar pages = [\n  'about',\n  'help',\n  'blog',\n  'tos',\n  'privacy',\n  'apps',\n  'api',\n  'advertise',\n  'privacy',\n  'removalrequest',\n  'jobs'\n];\n\nfunction parse(urlString) {\n  var urlParseResult = urlParse(urlString);\n\n  // make sure that the url we have been given is actually imgur\n  if (validHostNames.indexOf(urlParseResult.hostname) === -1) {\n    return null;\n  }\n\n  var pathComponents = urlParseResult.pathname.split('/'); // the 0th component is always empty\n\n  if ((pathComponents.length === 3) && (pathComponents[1] === 'gallery')) {\n    return {\n      type: 'gallery',\n      id: pathComponents[2]\n    };\n  } else if ((pathComponents.length === 4) && (pathComponents[1] === 'r')) {\n    return {\n      type: 'reddit',\n      subreddit: pathComponents[2],\n      id: pathComponents[3]\n    }\n  } else if ((pathComponents.length === 3) && (pathComponents[1] === 'a')) {\n    return {\n      type: 'album',\n      id: pathComponents[2]\n    };\n  } else if ((pathComponents.length === 2) && (pages.indexOf(pathComponents[1]) === -1)) {\n    var nameComponents = pathComponents[1].split('.');\n    if (nameComponents.length <= 2) {\n      return {\n        type: 'image',\n        id: nameComponents[0],\n        fileType: nameComponents[1]\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction parsedToImageId(parsedUrl) {\n  if (parsedUrl) {\n    if (parsedUrl.type === 'gallery' || parsedUrl.type === 'reddit' || parsedUrl.type === 'image') {\n      return parsedUrl.id;\n    } else if (parsedUrl.type === 'album') {\n      // TODO no idea what to do here\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction imageIdFromUrl(urlString) {\n  return parsedToImageId(parse(urlString));\n}\n\nmodule.exports = {\n  _validHostNames: validHostNames,\n  _pages: pages,\n  parse: parse,\n  parsedToImageId: parsedToImageId,\n  imageIdFromUrl: imageIdFromUrl\n};\n"]}